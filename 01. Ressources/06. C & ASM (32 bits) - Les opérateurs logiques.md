# C & ASM (32 bits) - Les opérateurs de traitement des bits
Les opérateurs logiques, au nombre de 6, permettent d'effectuer des opérations au niveau des bits.

## Sommaire
* [L'addition](https://github.com/Sharpforce/Reverse-Engineering/blob/master/01.%20Ressources/05.%20C%20%26%20ASM%20(32%20bits)%20-%20Les%20op%C3%A9rations%20math%C3%A9matiques.md#laddition)
* [La soustraction](https://github.com/Sharpforce/Reverse-Engineering/blob/master/01.%20Ressources/05.%20C%20%26%20ASM%20(32%20bits)%20-%20Les%20op%C3%A9rations%20math%C3%A9matiques.md#la-soustraction)
* [La multiplication](https://github.com/Sharpforce/Reverse-Engineering/blob/master/01.%20Ressources/05.%20C%20%26%20ASM%20(32%20bits)%20-%20Les%20op%C3%A9rations%20math%C3%A9matiques.md#la-multiplcation)
* [La division](https://github.com/Sharpforce/Reverse-Engineering/blob/master/01.%20Ressources/05.%20C%20%26%20ASM%20(32%20bits)%20-%20Les%20op%C3%A9rations%20math%C3%A9matiques.md#la-division)
* [Le modulo](https://github.com/Sharpforce/Reverse-Engineering/blob/master/01.%20Ressources/05.%20C%20%26%20ASM%20(32%20bits)%20-%20Les%20op%C3%A9rations%20math%C3%A9matiques.md#le-modulo)

## Le ET (AND) bit à bit
Le **ET** bit à bit est utilisé en général afin de mettre certains bits à zéro en fonction d'un masque. Par exemple un **ET** entre la valeur "5" (soit en binaire "0101") et "12" (soit en binaire "1100") donne "4" (soit "0100" en binaire) :
```c
int main(int argc, char **argv) {
  int a = 5;
  int b = 12;
  int c;

  c = a & b;

  return 0;
}
```

Et en assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 05 00 00 00    mov    DWORD PTR [ebp-0x4],0x5
80483e8:       c7 45 f8 0c 00 00 00    mov    DWORD PTR [ebp-0x8],0xc
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       23 45 f8                and    eax,DWORD PTR [ebp-0x8]
80483f5:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f8:       b8 00 00 00 00          mov    eax,0x0
80483fd:       c9                      leave
80483fe:       c3                      ret
```

**Explication :** L'instruction _and_ effectue un **ET (&)** bit à bit entre _ebp-0x8_ et _ebp-0x4_ soit respectivement "12" et "5". Le résultat est stocké dans la variable "c" à _ebp-0xc_ et a pour valeur "4".

## Le OU (OR) bit à bit
Le **OU** est très souvent utilisé pour activer des drapeaux ou options à une fonction par exemple. Cet opérateur a pour effet de mettre à un certains bits. Par exemple un **OU** entre la valeur "5" (soit en binaire "0101") et "12" (soit en binaire "1100") donne "13" (soit "1101" en binaire) :
```c
int main(int argc, char **argv) {
  int a = 5;
  int b = 12;
  int c;

  c = a | b;

  return 0;
}
```

Et en assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 05 00 00 00    mov    DWORD PTR [ebp-0x4],0x5
80483e8:       c7 45 f8 0c 00 00 00    mov    DWORD PTR [ebp-0x8],0xc
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       0b 45 f8                or     eax,DWORD PTR [ebp-0x8]
80483f5:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f8:       b8 00 00 00 00          mov    eax,0x0
80483fd:       c9                      leave
80483fe:       c3                      ret
```

**Explication :** L'instruction _or_ effectue un **OU (|)** bit à bit entre _ebp-0x8_ et _ebp-0x4_ soit respectivement "12" et "5". Le résultat est stocké dans la variable "c" à _ebp-0xc_ et a pour valeur "13".

## Le OU exclusif (XOR) bit à bit
Il permet de ne garder seulement les bits déjà à un dans une des deux valeurs. Par exemple un **XOR** entre la valeur "5" (soit en binaire "0101") et "12" (soit en binaire "1100") donne "9" (soit "1001" en binaire) :
```c
int main(int argc, char **argv) {
  int a = 3;
  int b = 2;
  int c;

  c = a ^ b;

  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 05 00 00 00    mov    DWORD PTR [ebp-0x4],0x5
80483e8:       c7 45 f8 0c 00 00 00    mov    DWORD PTR [ebp-0x8],0xc
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       33 45 f8                xor    eax,DWORD PTR [ebp-0x8]
80483f5:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f8:       b8 00 00 00 00          mov    eax,0x0
80483fd:       c9                      leave
80483fe:       c3                      ret
```

**Explication :** L'instruction _xor_ effectue un **OU EXCLUSIF (^)** bit à bit entre _ebp-0x8_ et _ebp-0x4_ soit respectivement "12" et "5". Le résultat est stocké dans la variable "c" à _ebp-0xc_ et a pour valeur "9".

## Le complément à un
Le complément à un est un opérateur unaire (il prend un seul paramètre). Il a pour objectif d'inverser les bits. Tous les bits à un deviennent zéro et inversement. Par exemple la valeur "9" (soit "1001" en binaire) donne "6" (soit "0110" en binaire) :
```c
int main(int argc, char **argv) {
  int a = 9;
  int c;

  c = 15 & ~a;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 09 00 00 00    mov    DWORD PTR [ebp-0x4],0x9
80483e8:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483eb:       f7 d0                   not    eax
80483ed:       83 e0 0f                and    eax,0xf
80483f0:       89 45 f8                mov    DWORD PTR [ebp-0x8],eax
80483f3:       b8 00 00 00 00          mov    eax,0x0
80483f8:       c9                      leave
80483f9:       c3                      ret
```

**Explication :** L'instruction _not_ permet de récupérer la négation de la variable "a" (qui vaut "9"). Le résultat est stocké dans la variable "c" et a pour valeur "6". Le "&" est nécessaire afin d'effectuer un masque sur les 4 premiers bits de la variable "a" ("15" vaut "1111" en binaire soit les 4 premiers bits à 1, si cela était omit alors des effets de bords peuvent apparaître à cause du bit de signe).

## Le décalage à gauche "<<"
Le décalage à gauche permet de décaler d'un certain nombre de bits la valeur affectée. Par exemple la valeur "1" (soit en binaire "0001") vaudra "2" (soit en binaire "0010") pour un décalage de "1", mais vaudra "4" (soit en binaire "0100") pour un décalage de "2" etc :            
```c
int main(int argc, char **argv) {
  int a = 1;
  int c;

  c = a << 2;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 01 00 00 00    mov    DWORD PTR [ebp-0x4],0x1
80483e8:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483eb:       c1 e0 02                shl    eax,0x2
80483ee:       89 45 f8                mov    DWORD PTR [ebp-0x8],eax
80483f1:       b8 00 00 00 00          mov    eax,0x0
80483f6:       c9                      leave
80483f7:       c3                      ret
```

**Explication :** L'instruction _shl_ pour _shifl left_ permet de décaler de "2" la valeur de la variable stockée à _ebp-0x4_. Dans le cas de l'exemple la valeur "1" est décalée de "2", le résultat stocké dans "c" vaut alors "4".

## Le décalage à droite ">>"
Le décalage à droite permet de décaler d'un certain nombre de bits la valeur affectée. Par exemple la valeur "2" (soit en binaire "0010") vaudra "1" (soit en binaire "0001") pour un décalage de "1" :            
```c
int main(int argc, char **argv) {
  int a = 2;
  int c;

  c = a >> 1;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 02 00 00 00    mov    DWORD PTR [ebp-0x4],0x2
80483e8:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483eb:       d1 f8                   sar    eax,1
80483ed:       89 45 f8                mov    DWORD PTR [ebp-0x8],eax
80483f0:       b8 00 00 00 00          mov    eax,0x0
80483f5:       c9                      leave
80483f6:       c3                      ret
```

**Explication :** L'instruction _sar_ pour _shifl arithmetic right_ permet de décaler de "1" la valeur de la variable stockée à _ebp-0x4_. Dans le cas de l'exemple la valeur "2" est décalée de "1", le résultat stocké dans "c" vaut alors "1". Une subtilité ici est que _sar_ permet de sauvegarder le bit de signe (il s'agit du bit le plus significatif nommé également _msb_). Il existe donc aussi l'instruction _shr_ pour _shift right_.

## Sources
* [http://www.bien-programmer.fr/bits.htm](http://www.bien-programmer.fr/bits.htm)