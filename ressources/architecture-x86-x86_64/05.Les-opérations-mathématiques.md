# Les opérations mathématiques
Dans ce chapitre, les opérations mathématiques regroupent les opérations : addition, soustraction, multiplication, division et modulo. Ils seront effectuées sur des entiers.

## L'addition
L'addition du chiffre "3" par le chiffre "2" peut se représenter comme ceci :
```c
int main(int argc, char **argv) {
  int a = 3;
  int b = 2;
  int c;

  c = a + b;
  return 0;
}
```

Et en assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
80483e8:       c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
80483ef:       8b 55 fc                mov    edx,DWORD PTR [ebp-0x4]
80483f2:       8b 45 f8                mov    eax,DWORD PTR [ebp-0x8]
80483f5:       01 d0                   add    eax,edx
80483f7:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483fa:       b8 00 00 00 00          mov    eax,0x0
80483ff:       c9                      leave
8048400:       c3                      ret
```

**Explication :** Une fois les valeurs "3" et "2" stockées respectivement dans _ebp-0x4_ (soit "a") et _ebp-0x8_ (soit "b"), elles sont tout d'abord déplacées dans les registres de travail _edx_ et _eax_. Puis, vient l'addition via l'instruction _add_ et les opérandes _eax_ et _edx_. Après une telle opération le résultat est en général stocké dans le registre _eax_. La dernière instruction intéressante est la sauvegarde du registre _eax_ (contenant le résultat de l'addition) dans la variable "c" stocké à _ebp-0xc_.

## La soustraction
La soustraction s'effectue de la même façon que l'addition, il suffit de remplacer l'opération _add_ par l'opération _sub_ :
```c
int main(int argc, char **argv) {
  int a = 3;
  int b = 2;
  int c;

  c = a - b;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
80483e8:       c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       2b 45 f8                sub    eax,DWORD PTR [ebp-0x8]
80483f5:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f8:       b8 00 00 00 00          mov    eax,0x0
80483fd:       c9                      leave
80483fe:       c3                      ret
```

**Explication :** Il s'agit des mêmes instructions que pour l'addition. Petite différence à noter, ici le registre _edx_ n'est pas utilisé afin d'effectuer la soustraction.

## La multiplcation
La multiplication 3 par 2 peut donner ce qui suit :
```c
int main(int argc, char **argv) {
  int a = 3;
  int b = 2;
  int c;

  c = a * b;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
80483e8:       c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       0f af 45 f8             imul   eax,DWORD PTR [ebp-0x8]
80483f6:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f9:       b8 00 00 00 00          mov    eax,0x0
80483fe:       c9                      leave
80483ff:       c3                      ret
```

**Explication :** Pas de grande nouveauté, seul l'instruction utilisée est nouvelle : _imul_, utilisée pour la multiplication d'entiers signés.

## La division
La soustraction de 4 par 2 donne ceci :
```c
int main(int argc, char **argv) {
  int a = 4;
  int b = 2;
  int c;

  c = a / b;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 04 00 00 00    mov    DWORD PTR [ebp-0x4],0x4
80483e8:       c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       99                      cdq
80483f3:       f7 7d f8                idiv   DWORD PTR [ebp-0x8]
80483f6:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
80483f9:       b8 00 00 00 00          mov    eax,0x0
80483fe:       c9                      leave
80483ff:       c3                      ret
```

**Explication :** L'instruction _idiv_ permet d'effectuer une division sur des entiers signés. L'instruction de division ne contient qu'un seul opérande, (ici _ebp-0x8_ soit "2" qui est alors le diviseur). Le dividende se situe en fait dans le registre _eax_, qui ici, contient _ebp-0x4_ (soit "4"). Concernant la conversion, cela provient du fait que le dividende sera stocké sous 64 bits et le diviseur sous 32 bits. Mais comment stocker une valeur sur 64 bits alors que l'architecture est en 32 bits ? Il suffit d'utiliser 2 registres (de 32 bits), ce qui donnera un dividende stocké dans _edx:eax_. En d'autres termes, l'instruction _cqd_ permet de stocker le contenu de _eax_ (32 bits) dans _edx:eax_. Plus précisemment, c'est le bit de poids fort du registre _eax_ qui sera étendu aux bits du registre _edx_. A noter également que le registre _eax_ contiendra le quotient et le registre _edx_ le reste de la division.

## Le modulo
Pour rappel, le modulo est le reste de la vision :
```c
int main(int argc, char **argv) {
  int a = 4;
  int b = 3;
  int c;

  c = a % b;
  return 0;
}
```

En assembleur :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 04 00 00 00    mov    DWORD PTR [ebp-0x4],0x4
80483e8:       c7 45 f8 03 00 00 00    mov    DWORD PTR [ebp-0x8],0x3
80483ef:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
80483f2:       99                      cdq
80483f3:       f7 7d f8                idiv   DWORD PTR [ebp-0x8]
80483f6:       89 55 f4                mov    DWORD PTR [ebp-0xc],edx
80483f9:       b8 00 00 00 00          mov    eax,0x0
80483fe:       c9                      leave
80483ff:       c3                      ret
```

**Explication :** Le code assembleur est le même que pour la division (voir l'exemple précédent). Il faut toutefois se rappeler que, lors d'une division, le reste est stocké dans le registre _edx_. C'est pour cette raison que le contenu du registre _edx_ est copié dans _ebp-0xc_ (soit la variable "c") et non le contenu du registre _eax_ comme précédemment.

---

[Sommaire](../../README.md) | [Page suivante](06.Les-opérateurs-logiques.md)