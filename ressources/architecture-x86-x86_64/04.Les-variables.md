# Les variables
Les variables servent à stocker des données. Mais elles ne sont pas toutes égales, car, dans un programme, elles ne sont pas toutes stockées au même endroit. Certaines sont stockées directement dans la pile, quand d'autres, seront stockées dans le tas par exemple.

## Les variables locales

### Type entier (int)
Le premier cas peut être l'initialisation de variables locales (à une fonction) :
```c
int main(int argc, char **argv) {
  int a = 5;
  int b = 8;
  
  return 0;
}
```

Et son équivalent en assembleur : 
```asm
01: 80483db:       55                      push   ebp
02: 80483dc:       89 e5                   mov    ebp,esp
03: 80483de:       83 ec 10                sub    esp,0x10
04: 80483e1:       c7 45 fc 05 00 00 00    mov    DWORD PTR [ebp-0x4],0x5
05: 80483e8:       c7 45 f8 08 00 00 00    mov    DWORD PTR [ebp-0x8],0x8
06: 80483ef:       b8 00 00 00 00          mov    eax,0x0
07: 80483f4:       c9                      leave
08: 80483f5:       c3                      ret
```

**Explication :** Les lignes 1 à 3 représentent le _prologue_ de la fonction et sera étudié dans un chapitre ultérieur. Ligne 4 et 5, les valeurs 5, soit la variable "a", et 8, soit la variable "b", sont copiées sur la pile respectivement à _EBP-0x4_ et _EBP-0x8_. Les lignes 6 à 8 représentent l'_épilogue_ de la fonction et sera également étudié dans un autre chapitre.

![Schéma pile variables locales de type entier](images/alloc_variable_locale_int.png)

### Caractère (char)
Un autre exemple intéressant peut être l'allocation d'un caractère (soit 1 seul octet) :
```c
int main(int argc, char **argv) {
  char monChar = 'a';
  
  return 0;
}
```

```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c6 45 ff 61             mov    BYTE PTR [ebp-0x1],0x61
80483e5:       b8 00 00 00 00          mov    eax,0x0
80483ea:       c9                      leave
80483eb:       c3                      ret
```

**Explication :** La valeur "a" (soit en héxa "0x61") est stockée dans la pile à seulement _ebp - 0x1_ car un caractère peut être stocké sur un seul octet (ce que confirme l'utilisation d'un _BYTE_).

![Schéma pile variables locales de type char](images/alloc_variable_locale_char.png)

### Chaîne de caractères
Il est possible d'initialiser une chaîne de caractère de cette façon :
```c
int main(int argc, char **argv) {
  char maChaine[] = "abcdefghijklmnopqrstuvwxyz";

  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 20                sub    esp,0x20
80483e1:       c7 45 e5 61 62 63 64    mov    DWORD PTR [ebp-0x1b],0x64636261
80483e8:       c7 45 e9 65 66 67 68    mov    DWORD PTR [ebp-0x17],0x68676665
80483ef:       c7 45 ed 69 6a 6b 6c    mov    DWORD PTR [ebp-0x13],0x6c6b6a69
80483f6:       c7 45 f1 6d 6e 6f 70    mov    DWORD PTR [ebp-0xf],0x706f6e6d
80483fd:       c7 45 f5 71 72 73 74    mov    DWORD PTR [ebp-0xb],0x74737271
8048404:       c7 45 f9 75 76 77 78    mov    DWORD PTR [ebp-0x7],0x78777675
804840b:       66 c7 45 fd 79 7a       mov    WORD PTR [ebp-0x3],0x7a79
8048411:       c6 45 ff 00             mov    BYTE PTR [ebp-0x1],0x0
8048415:       b8 00 00 00 00          mov    eax,0x0
804841a:       c9                      leave
804841b:       c3                      ret
```

**Explication :** La chaîne de caractère est donc chargée au sein de la pile sur le même principe que précedemment (A noter la présence du caractère "\0" indiquant la fin de la chaîne).

![Schéma pile variables locales type tableau de string](images/alloc_variable_locale_string.png)

Il est également possible de représenter une chaîne en utilisant un pointeur :
```c
int main(int argc, char **argv) {
  char *maChaine = "abcdefghijklmnopqrstuvwxyz";

  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       83 ec 10                sub    esp,0x10
80483e1:       c7 45 fc 70 84 04 08    mov    DWORD PTR [ebp-0x4],0x8048470
80483e8:       b8 00 00 00 00          mov    eax,0x0
80483ed:       c9                      leave
80483ee:       c3                      ret
```

**Explication :** Dans la pile, un pointeur pointant vers l'adresse _0x8048470_ est placé à _ebp-0x4_. Pour analyser le contenu de la chaîne il faut donc visualiser le contenu de l'adresse en question. La différence principale est que, cette fois, la chaîne est stockée au sein de la section _data_ et non dans la pile (qui contient donc seulement l'adresse de la chaîne stockée dans la section _data_).

![Schéma pile variables locales de type pointeur de string](images/alloc_variable_locale_string_ptr.png)

### L'utilitaire strings
L'utilitaire *strings* sous Unix permet d'afficher toutes les chaînes de caractères imprimables d'un fichier. Cet outil peut être très utile pour connaitre les constantes et autres chaînes hard-codées dans un binaire. En reprenant le code source précédent cela donne :
```
$ strings monProgramme
/lib/ld-linux.so.2
-"g
]v<iB~&
libc.so.6
_IO_stdin_used
__libc_start_main
__gmon_start__
GLIBC_2.0
PTRhP
UWVS
t$,U
[^_]
abcdefghijklmnopqrstuvwxyz
;*2$"
GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516
prog.c
argv
...
```

Bien que de nombreuses informations apparaissent, la chaîne "abcdefghijklmnopqrstuvwxyz" est bien présente.

## Les variables globales
Les variables globales ont l'avantage d'être accessibles dans tout le programme. Il est facile d'en déduire qu'elles ne peuvent être stockées dans la pile, la _stack frame_ représentant le contexte d'une seule fonction.

### Initialisée
Dans le cas d'une variable globale initialisée puis modifiée :
```c
int id_process = 1;

int main(int argc, char **argv) {
  id_process = 1456;
  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       c7 05 18 a0 04 08 b0    mov    DWORD PTR ds:0x804a018,0x5b0
80483e5:       05 00 00
80483e8:       b8 00 00 00 00          mov    eax,0x0
80483ed:       5d                      pop    ebp
80483ee:       c3                      ret
```

**Explication :** Premièrement, le prologue ne réserve pas d'espace supplémentaire dans la pile en effectuant la soustraction sur le registre _esp_. La valeur hexadécimale "0x5b0" (représentant la valeur "1456" en décimale) est chargée dans la section _data_ qui stocke les variables globales et statiques initialisées, soit ici à l'adresse _0x804a01c_.

### Non initialisé
Dans le cas d'une variable globale non initialisée puis modifiée :
```c
int id_process;

int main(int argc, char **argv) {
  id_process = 1456;
  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       c7 05 1c a0 04 08 b0    mov    DWORD PTR ds:0x804a01c,0x5b0
80483e5:       05 00 00
```

**Explication :** Le prologue ne réserve toujours pas d'espace supplémentaire dans la pile. La valeur hexadécimale "0x5b0" (représentant la valeur "1456" en décimale) est chargée dans la section _bss_ qui stocke les variables globales et statiques non initialisées, soit ici à l'adresse _0x804a01c_.

**Note :** Il est intéressant de voir qu'une variable globale initialisée à la valeur "0" sera stockée dans la section _bss_ et non _data_. En fait, tout les variables non initialisées sont implicitement mises à "0" (ou _NULL_ pour les pointeurs).

## Les variables statiques
Les variables statiques ont l'avantage d'avoir une durée de vie supérieure aux variables locales (elles survivent d'un appel à l'autre), il est facile d'en déduire qu'elles ne peuvent être stockées dans la pile, la _stack frame_ représentant le contexte d'une seule fonction.

### Initialisée
Dans le cas d'une variable statique initialisée puis modifiée :
```c
int main(int argc, char **argv) {
  static int nb_processus = 1;

  nb_processus = 2;
  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       c7 05 18 a0 04 08 02    mov    DWORD PTR ds:0x804a018,0x2
80483e5:       00 00 00
80483e8:       b8 00 00 00 00          mov    eax,0x0
80483ed:       5d                      pop    ebp
80483ee:       c3                      ret
```

**Explication :** Premièrement, le prologue ne réserve pas d'espace supplémentaire dans la pile en effectuant la soustraction sur le registre _esp_. La valeur hexadécimale "0x2" (représentant la valeur "2" en décimale) est chargée dans la section _data_ qui stocke les variables globales et statiques initialisées, soit ici à l'adresse _0x804a018_.

### Non initialisée
Dans le cas d'une variable statique non initialisée puis modifiée :
```c
int main(int argc, char **argv) {
  static int nb_processus;

  nb_processus = 1;
  return 0;
}
```

Le code assembleur correspondant :
```asm
80483db:       55                      push   ebp
80483dc:       89 e5                   mov    ebp,esp
80483de:       c7 05 1c a0 04 08 01    mov    DWORD PTR ds:0x804a01c,0x1
80483e5:       00 00 00
80483e8:       b8 00 00 00 00          mov    eax,0x0
80483ed:       5d                      pop    ebp
80483ee:       c3                      ret
```

**Explication :** Le prologue ne réserve toujours pas d'espace supplémentaire dans la pile. La valeur hexadécimale "0x1" (représentant la valeur "1" en décimale) est chargée dans la section _bss_ qui stocke les variables globales et statiques non initialisées, soit ici à l'adresse _0x804a01c_.

**Note :** Il est intéressant de voir qu'une variable statique initialisée à la valeur "0" sera stockée dans la section _bss_ et non _data_. En fait, tout les variables non initialisées sont implicitement mises à "0" (ou _NULL_ pour les pointeurs).

## L'allocation de mémoire dynamique
Il est possible d'allouer de la mémoire dynamiquement en utilisant par exemple la méthode _malloc()_ :
```c
#include <stdlib.h>

int main(int argc, char **argv) {
  int *p = malloc (sizeof(int));
  
  return 0;
}
```

Le code assembleur correspondant :
```asm
804840b:       8d 4c 24 04             lea    ecx,[esp+0x4]
804840f:       83 e4 f0                and    esp,0xfffffff0
8048412:       ff 71 fc                push   DWORD PTR [ecx-0x4]
8048415:       55                      push   ebp
8048416:       89 e5                   mov    ebp,esp
8048418:       51                      push   ecx
8048419:       83 ec 14                sub    esp,0x14
804841c:       83 ec 0c                sub    esp,0xc
804841f:       6a 04                   push   0x4
8048421:       e8 ba fe ff ff          call   80482e0 <malloc@plt>
8048426:       83 c4 10                add    esp,0x10
8048429:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
804842c:       8b 45 f4                mov    eax,DWORD PTR [ebp-0xc]
804842f:       c7 00 05 00 00 00       mov    DWORD PTR [eax],0x5
8048435:       b8 00 00 00 00          mov    eax,0x0
804843a:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
804843d:       c9                      leave
804843e:       8d 61 fc                lea    esp,[ecx-0x4]
8048441:       c3                      ret
```

Cela se complique légèrement ici. Voici un zoom sur ce qui suit l'appel à _malloc()_ :
```asm
8048421:       e8 ba fe ff ff          call   80482e0 <malloc@plt>
8048426:       83 c4 10                add    esp,0x10
8048429:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
804842c:       8b 45 f4                mov    eax,DWORD PTR [ebp-0xc]
804842f:       c7 00 05 00 00 00       mov    DWORD PTR [eax],0x5
```

**Explication :** Le registre _eax_ contient le retour de la fonction _malloc()_ soit ici le pointeur nommé _p_. Puis _p_ est copié à l'adresse _ebp-0xc_ qui correspond à un emplacement dans le tas. En effet, les variables allouées dynamiquement sont stockées dans le tas et non dans la pile (le tas se situe à une adresse plus basse que la pile).

## Un peu de pratique - Challenge n°01
Enfin ! Le premier challenge ! Have fun :)

[Challenge n°01](../../challenges/architecture-x86-x86_64/un_peu_de_pratique-challenge_01/README.md)

---

[Sommaire](../../README.md) | [Page suivante](05.Les-opérations-mathématiques.md)